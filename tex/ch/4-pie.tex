% ! TEX root = ../racket.tex
\chapter{Pie}

Pie is a language implemented in Racket meant to facilitate programming
and theorem proving with dependent types. It is best described in the
book \cite{typer}, which is written in a very original way, by means of
dialogue, as a theater play, with emphasis on interaction and asking
questions. In fact, the book is only one in a series generally titled
\emph{The Little X}, where \emph{X} so far has been
\emph{Schemer, Lisper, Prover, Haskeller}.

In this chapter, we will present some basic syntax and features of Pie
first and then insist on its implementation of dependent types. Most
of the presentation will follow \cite{typer}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Basic Syntax and Features}

Since Pie is written in Racket, its syntax is similar to Racket's.
Moreover, the language is available as a Racket module, hence it can be
installed using the Racket packet manager, \texttt{raco}. After that,
any source code file will start with the pragma (module call)
\texttt{\#lang pie} and it will be interpreted accordingly.
\index{Pie!\texttt{raco} module}

Since the language is strongly typed, that is, the user must associate a
type to each variable or function they use, all the definitions must be
preceded either by a \texttt{claim} or a \texttt{the} statement.
\index{Pie!\texttt{claim}}
\index{Pie!\texttt{the}}
\index{Pie!\texttt{define}}

A \texttt{claim} statement declares the type of a function or variable
and must precede any definition, whereas a \texttt{the} expression
does a type annotation for variables. Simple examples follow:
{
  \small
\begin{verbatim}
#lang pie

(the (Pair Atom Atom)
     (cons 'spinach 'cauliflower))
;; declares that the expression (cons 'spinach 'cauliflower)
;; makes a Pair of Atoms. more on these below

(claim one Nat)                 ; one is of type Nat
(define one (add1 zero))        ; zero is primitive
(the Nat (add1 one))            ; 2 is a Nat
\end{verbatim}
}

\index{Pie!types!\texttt{Nat}}
\index{Pie!types!\texttt{Atom}}

Two basic types that can be used are \texttt{Nat}, for positive integers,
\texttt{Atom} for quoted variables (symbols). Then, we can use
\emph{constructors} and \emph{type constructors}. An expression that is
preceded by a constructor is called a \emph{value}. For example, one constructor
of the type \texttt{Nat} is \texttt{zero}, which returns \texttt{0} and another
one is \texttt{add1}, which is basically the successor function. So for
example, we can obtain a value like so:
{
  \small
\begin{verbatim}
#lang pie

(claim two Nat)
(define two
  (add1
    (add1 zero)))
\end{verbatim}
}

Also, atoms are values, so the type \texttt{Atom} does not have a constructor:
{
  \small
\begin{verbatim}
#lang pie

(claim dog Atom)
(define dog 'dog)
\end{verbatim}
}

Then, further, we can build types using \emph{type constructors}. One example
is the type constructor \texttt{Pair} which makes a pair of elements having
(possibly) different types. A constructor for such a type is \texttt{cons}:
{
  \small
\begin{verbatim}
#lang pie

(claim myDogs (Pair Atom Atom))
(define myDogs (cons 'Ricky 'Rocky))
\end{verbatim}
}

We will meet more types and (type) constructors further, so we will explain
them on the spot. Notice that we can also use lambda expressions, as
throughout Racket.

One last important feature which we mention here is that the type theory that
we use is, in a sense, \emph{closed} or \emph{total}. That is, anything must
have a type... \emph{including types!} Without going into details, we mention
that the type of types is one all-encompassing \emph{universe}, denoted
mathematically by $ \kal{U} $ and in Pie, by \texttt{U}. We will meet universes
when we build $ \Pi $-types in Pie.
\index{Pie!types!\texttt{U} (universe)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Induction and Dependent Types}
\label{sec:induction-pi}

We now are heading towards more complex features of Pie, of which
dependent types are an essential example. But before we get there,
we will introduce some functions which work on the basis of induction.
We provide explicit examples instead of focusing on theoretical aspects.
The theory between the principle of mathematical induction was
introduced on the type of natural numbers in \S\ref{sec:nat-ind}.

\index{Pie!induction!\texttt{which-Nat}}
As such, we first introduce the Pie function \texttt{which-Nat}.
The general syntax is:
\[
  \texttt{(which-Nat \ target \ base \ step)},
\]
which is a function that acts on \texttt{Nat} variables.
It works as follows:
\begin{itemize}
\item it first checks whether \texttt{target} is \texttt{zero};
\item if it is, the function returns the value of \texttt{base};
\item otherwise, \texttt{target} must be some \texttt{(add1 n)},
  for some \texttt{n}, since these are the only kinds of values of type
  \texttt{Nat}. In this case, it returns the value of \texttt{(step n)}.
\end{itemize}

This pattern will be encountered in some other functions as well,
so we will spend a little on explaining it better. The first argument
(both for \texttt{which-Nat} and some other similar functions that we
meet is, in a sense, \qq{the main argument}, since depending on its form,
the rest happens. In the case of \texttt{Nat} values, we can only encounter
either \texttt{zero} or \texttt{add1 n}. In the first case, the function
returns \texttt{base}, as if we are in the base case of an inductive proof.
In the second case, notice that if \texttt{target} has the form
\texttt{add1 n}, then we have access to the \emph{preceding} case, \texttt{n}.
So we also have \texttt{n} and \texttt{n + 1 = (add1 n)}. The function now
offers the flexibility to go not just from \texttt{n} to \texttt{n + 1},
but from \texttt{n} to \texttt{(step n)}. By abuse of language, we will still
call this \emph{the inductive step}. As such, whenever we use \texttt{which-Nat},
as well as the other similar functions that will appear, we want to make
sure we know what to do in \emph{the base case} and in the \emph{inductive step}.
In other words, we must have useful definitions both for \texttt{base}
and for \texttt{step}.

Some simple examples with \texttt{which-Nat} follow below. Notice that since
\texttt{which-Nat} is a standard library function for Pie, we don't have
to \texttt{claim} it.
{
  \small
\begin{verbatim}
#lang pie

(which-Nat zero
           'naught
          (lambda (n) 'more))           ;; => 'naught
(which-Nat 4
           'naught
           (lambda (n) 'more))          ;; => 'more
(which-Nat 5
           0
           (lambda (n) (+ 6 n)))        ;; => 10
\end{verbatim}
}
The first case is self explanatory: the \texttt{target} is exactly
\texttt{zero}, so we just get the base case, which is \texttt{'naught}.

In the second case, the \texttt{target} is not \texttt{zero}, so we
will evaluate the \texttt{step} case. For this, we first notice that
\texttt{4 = (add1 3)}, so \texttt{n = 3} and in this case, we get
the value of \texttt{((lambda (n) 'more) 3)}, which is \texttt{'more}.
Notice that in this lambda expression, the evaluation at \texttt{n = 3}
does nothing, since the lambda associates \texttt{'more} to any argument.

In the third case, however, we do have a more meaningful lambda.
Again, \texttt{target} is not \texttt{zero}, so we get the \texttt{step}
case. Since \texttt{5 = (add1 4)}, we get:
\[
  \texttt{((lambda (n) (+ 6 n)) 4) = 10}.
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example: \texttt{Pair} Types and functions}
\label{sec:pair-ex}
\index{Pie!types!\texttt{Pair}}

Let us now define a fully custom type, along with its eliminator
and a function that acts on values of this type. Following
\cite{typer}, we will call the type \texttt{Pear}. This is actually
a custom pair of two natural numbers so in a way, we are redefining
the type \texttt{(Pair Nat Nat)}. We first present the example and
comment it afterwards:
{
  \small
\begin{verbatim}
#lang pie

(claim Pear U)                      ; claim the custom type (of universal type)
(define Pear (Pair Nat Nat))        ; a Pear is a Pair of two Nats

(claim Pear-maker U)                ; type constructor, with the universal type
(define Pear-maker                  ; actual definition of the type constructor
  (-> Nat Nat Pear))                ; a functional type from 2 Nats to a Pear

(claim elim-Pear                    ; the type eliminator
    (-> Pear Pear-maker Pear))      ; takes a (Pear, Pear-maker), gives a Pear
(define elim-Pear                   ; the definition of the eliminator
  (lambda (pear maker)              ; is a lambda taking a pear and a maker
    (maker (car pear) (cdr pear)))) ; sends the maker on the first part of pear
                                    ; and on the second part of pear

(claim pearwise+                    ; addition for Pears
  (-> Pear Pear Pear))              ; takes two Pears and returns a third one
(define pearwise+                   ; (a, b) + (c, d) = (a + c, b + d)
  (lambda (x y)                     ; take the two parts (Nats)
    (elim-Pear x                    ; split the first    (Nat)
      (lambda (a1 d1)               ; into a1 and d1     (Nats)
        (elim-Pear y                ; split the second   (Nat)
          (lambda (a2 d2)           ; into a2 and d2     (Nats)
            (cons                   ; use the Pair constructor
              (+ a1 a2)             ; to make a Pair of their added components
              (+ d1 d2))))))))
\end{verbatim}
}

Since all the definitions are actually lambda expressions, it could seem
difficult to test some examples. Here is a use case, which we will comment
afterwards:
{
  \small
\begin{verbatim}
(elim-Pear (cons 3 17)
           (lambda (a d) (cons d a)))
;; is the same as
((lambda (pear maker)
    (maker (car pear) (cdr pear)))
  (cons 3 17)
  (lambda (a d) (cons d a)))
;; which finally reduces to
(cons 17 3)
\end{verbatim}
}
\index{Pie!types!constructor}
\index{Pie!types!eliminator}

The explanations are something like this. Note that in order to correctly
evaluate \texttt{elim-Pear}, its arguments must be a \texttt{Pear}
(that is, a \qq{custom} \texttt{Pair}), which we must write using a
\texttt{cons}, to make sure the output has the required type. Otherwise,
for example, just using \texttt{(3 17)} or some other seemingly clear
pair would not do. The second argument must be a \texttt{Pear-maker},
which we can see in the code that it is a function that takes two
\texttt{Nat}s and returns a \texttt{Pear}. In our case, it is a
lambda expression with two arguments which uses \texttt{cons} to make sure
it returns a \texttt{Pear}.

Then we actually evaluate the lambda expression which is equivalent to
the \texttt{elim-Pear} expression. The outermost lambda uses two arguments,
\texttt{pear} and \texttt{maker}, so when evaluating, they bind as:
\begin{itemize}
\item \texttt{pear} becomes \texttt{(cons 3 17)};
\item \texttt{maker} becomes \texttt{(lambda (a d) (cons d a))}, which
  is just a flip function for \texttt{Pair}s (or \texttt{Pear}s).
\end{itemize}
Looking at the outermost lambda again, we see that what it does to its arguments
is to apply the \texttt{maker} to the halves of the \texttt{pear}. In our case,
taking the \texttt{car} of \texttt{pear} returns \texttt{3} and its \texttt{cdr}
is \texttt{17}. So we just \texttt{cons} them in reverse order and get
\texttt{(17 3)}. In fact, the answer of the REPL is:
\[
  \texttt{(the (Pair Nat Nat) (cons 17 3))},
\]
which shows the types explicitly.

To make matters more difficult, but also more verbose and more in the DIY
style we are taking here, if one tries to use the \texttt{pearwise+} sum,
one finds surprisingly that the \texttt{+} function is not defined! Therefore,
addition is not a part of the standard library of Pie. This makes sense in a way,
since using dependent types enforces custom definitions either in a uniform
way using \texttt{Pi} or special definitions for each type. In this case,
in order to define addition for the type \texttt{Nat}, which we need for the
components of a \texttt{Pear = (Pair Nat Nat)} type, we also require another
function which behaves somewhat inductively. This is \texttt{iter-Nat},
whose general syntax is similar to what we will be seeing more of in
\S\ref{sec:induction-pi} and \S\ref{sec:inductive-ex}. That is, we have:
\[
  \texttt{(iter-Nat target base step)},
\]
which works as follows:
\begin{itemize}
\item if the value of \texttt{target} is \texttt{zero}, it returns
  the value of \texttt{base};
\item otherwise, if \texttt{target} is some \texttt{(add1 n)},
  the value of the expression is:
  \[
    \texttt{(step (iter-Nat n base step))}.
  \]
  In other words, it performs the \qq{inductive processing step}
  on the previous case.
\end{itemize}

Having this at hand, we can define addition for the \texttt{Nat} type.
\begin{figure}[!htbp]
  
  {
    \small
\begin{verbatim}
#lang pie

;; first, define the inductive step
(claim step+ (-> Nat Nat))              ; it processes one Nat and returns another
(define step+                           ; just add one,
  (lambda (+n-1)                        ; but we renamed the argument to +n-1
    (add1 +n-1)))                       ; we are using the previous case

;; now the addition
(claim + (-> Nat Nat Nat))              ; addition for the type Nat
(define +                               
  (lambda (n j)
    (iter-Nat n j step+)))
\end{verbatim}
  }
  \caption{Addition for the \texttt{Nat} type}
  \label{fig:plus-nat}
\end{figure}

\index{Pie!induction!\texttt{iter-Nat}}

Two remarks are in order at this point. First, a general Racket remark,
which in fact applies to most Lisps: variable names can use whatever
symbols the user wishes, including \texttt{+, -, /, ?} etc. In fact,
there are even common practices with them, for example, calling a predicate
(a function that returns a Boolean) with a question mark at the end. We have
met this in \S\ref{ch:proust} for symbol parsing with \texttt{symbol?}.

The second remark is about the actual definition of \texttt{+}. Notice that
it is a two-argument function which just calls \texttt{iter-Nat}. By
definition, if the first argument \texttt{n} is \texttt{zero}, we just get
\texttt{j} (the second argument), since $ 0 + j = j $. Otherwise, we use
the \qq{inductive step} \texttt{step+} to keep adding \texttt{1}. Notice,
moreover, that by the definition of \texttt{iter-Nat}, whenever we use the
\texttt{step} case, the \texttt{target} argument decreases. So it means that
\texttt{step+} will be called exactly \texttt{n} times, for \texttt{n, n-1,}
down to \texttt{1}.

We should also add the remark that no other \texttt{Nat} is defined except
for \texttt{zero} by default. So any addition we want to test must be
preceded by the \texttt{claim} and the definition of the numbers,
such as:
{
  \small
\begin{verbatim}
#lang pie

(claim three Nat)
(define three
  (add1 (add1 (add1 zero))))

;; now test addition
(+ (add1 zero) three)           ; => (the Nat 4)
\end{verbatim}
}

\vspace{0.3cm}

This was an exercise in the definition of a custom type, along with its
maker, eliminator and a function among variables of this type. We now focus
on standard types and examine how functions on types obtained using the
\texttt{Pair} type constructor are defined using dependent types.
What we will be writing is already included in the standard library, but their
breakdown and re-implementation is useful for education purposes.

The basic idea is the following: as we mentioned in the section on
dependent types (\S\ref{sec:depty}), want we want to achieve is to be able
to define functions on variables having different types \emph{in the same way}.
Here is how some functions on \texttt{Pairs} can be implemented:
{
  \small
\begin{verbatim}
#lang pie

(claim elim-Pair                ; "consumer" (eliminator) for Pairs
  (Pi ((A U) (D U) (X U))       ; will be used throughout, since it's
    (-> (Pair A D)              ; defined on product (parametrized) types
        (-> A D X) X)))
(define elim-Pair
  (lambda (A D X)
    (lambda (p f)
      (f (car p) (cdr p)))))

(claim kar                      ; replacement for car
  (-> (Pair Nat Nat) Nat))      ; for pairs of Nats
(define kar
  (lambda (p)
    (elim-Pair Nat Nat Nat p
      (lambda (a d) a))))

(claim kdr                      ; replacement for cdr
  (-> (Pair Nat Nat Nat)))      ; for pairs of Nats
(define kdr
  (lambda (p)
    (elim-Pair Nat Nat Nat p
      (lambda (a d) d))))

;; flipping two elements of a Pair
(claim flip
  (Pi ((A U) (D U))
    (-> (Pair A D) (Pair D A))))
(define flip
  (lambda (A D)                 ; abstract types first
    (lambda (p)                 ; then the actual pair
      (cons (cdr p) (car p))))) ; flip its halves
\end{verbatim}
}

We now explain the code above, since it contains some aspects that have not
been met so far. First, notice that we define the eliminator for \texttt{Pair}
types\footnotemark, but in such a way that it uses dependent types. This way,
we use the same definition regardless of the actual types that will appear in
the arguments by a supplementary abstraction on types.
\footnotetext{Formally, we should say something like \texttt{(Pair X Y)},
  where \texttt{X} and \texttt{Y} are types, since \texttt{Pair} itself is just
  a \emph{type constructor} that takes two arguments which are types to produce
  a type. But with this remark, we acknowledge the language abuse which we've
  done and continue doing it.}

Therefore, we first need to write that \texttt{elim-Pair} will be a \texttt{Pi}
type that depends on three types \texttt{A : U, D : U, X : U}. Then, what it will
actually do is to provide a function whose first argument is of type
\texttt{Pair A D} and the second argument is another function of type
\texttt{A -> D -> X} and finally, the output will have type \texttt{X}. The action
will become clear in the definition that follows the \texttt{claim}.
As such, how this works is the following:
\begin{itemize}
\item it first abstracts with respect to types. This is a key step in a dependent
  type, since as we mentioned, it must work on various types of arguments that
  it is fed and this is the place where the types of those arguments are made
  explicit;
\item then, the action is another abstraction, this time on two arguments, one
  being a function \texttt{f} and a pair \texttt{p}. How it works is that it splits
  the \texttt{p} in two, using \texttt{car} and \texttt{cdr} and it applies the
  function to both of these halves. Its use will become even more transparent
  in the examples that follow.
\end{itemize}

Then we implement \texttt{kar}, which mimics the behaviour of \texttt{car}
for \texttt{(Pair Nat Nat)} arguments, i.e.\ it returns the first part.
After \texttt{claim}ing its type, which is precisely \texttt{(Pair Nat Nat) -> Nat},
we \texttt{define} it as follows:
\begin{itemize}
\item we use \texttt{elim-Pair}, since it is the only \qq{consumer} of \texttt{Pair}
  types;
\item the first arguments of \texttt{elim-Pair} are the actual types with respect
  to which we do the first abstraction (i.e.\ the types that enter in \texttt{Pi}).
  In this case, all three of them are \texttt{Nat};
\item lastly, the non-type argument \texttt{p}, which is exactly the pair of
  naturals. How this works is to provide a function which, given two arguments, it
  returns the first one.
\end{itemize}

Let's do a bit of \qq{pattern-matching} in this definition, namely let's match
the concrete arguments in \texttt{kar}'s definition with the generic arguments
in the definition of \texttt{elim-Pair}. First of all, as we mentioned,
\texttt{A = D = X = Nat}. Then, the second argument of \texttt{elim-Pair}
must be of type \texttt{(Pair Nat Nat) -> (Nat -> Nat -> Nat) -> Nat}.
That is, it must accept a pair of \texttt{Nat}s and a function of two
\texttt{Nat} arguments that produces a third \texttt{Nat} and finally it
must return a \texttt{Nat}. But this becomes irrelevant in this case, since
in \texttt{kar} we are abstracting by some generic \texttt{p} and make it
act like a \texttt{lambda} that returns the first half of its arguments.
That is, what \texttt{kar} is doing (after mentioning the types) is the assignment:
\[
  \texttt{p} \mapsto \left( (a, d) \mapsto a \right).
\]
It is as if \texttt{p} gets renamed to \texttt{first}.

Similarly, \texttt{kdr} is a sort of \texttt{second}.

A very similar example was the custom \texttt{elim-Pear} function we defined
and used in \S\ref{sec:pair-ex}.

Now to test the \texttt{flip} function, we need to call it accordingly.
For example, we can first make it a particular flip function for certain
types:
\[
  \texttt{(flip Nat Atom)}
\]
is just the function that requires a \texttt{(Pair Nat Atom)} argument
which it binds to \texttt{p} and is then:
\[
  \texttt{(lambda (p) (cons (cdr p) (car p)))}.
\]
A particular example is:
\[
  \texttt{((flip Nat Atom) (cons 17 'apple))},
\]
which replies with:
\[
  \texttt{(the (Pair Atom Nat) (cons 'apple 17))}.
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example: \texttt{List} Types and Functions}
\label{sec:inductive-ex}
\index{Pie!types!\texttt{List}}


A sort of generalization of \texttt{Pair} types are \emph{lists}.
We now show how some functions on \texttt{List} types\footnotemark can
be implemented using dependent types.
\footnotetext{Again, as in the case of \texttt{Pair}, \texttt{List} is a
  \emph{type constructor}, so formally it is not correct to say
  \qq{\texttt{List} type}. It should be something like \texttt{List X} type,
  where \texttt{X} is a type. But as in the case of \texttt{Pair}s, we
  acknowledge and keep using this expression.}

First, the prerequisites. \texttt{(List X)} is a type, where \texttt{X}
is a type and this type has two \emph{constructors}:
\begin{itemize}
\item \texttt{nil}, which makes an empty list (similar to \texttt{zero}
  for \texttt{Nat});
\item \texttt{::}, which is the equivalent of \texttt{cons} for pairs.
\end{itemize}

Also as in the case of \texttt{Nat}, we have a special \qq{inductive}
function \texttt{rec-list}. Its general syntax is:
\[
  \texttt{(rec-List target base step)}
\]
and this produces an element of type \texttt{X} when:
\begin{itemize}
\item \texttt{target} is of type \texttt{(List E)};
\item \texttt{base} is of type \texttt{X};
\item \texttt{step} is of type \texttt{(-> E (List E) X X)}.
\end{itemize}

How this works is similar to \texttt{which-Nat} with a twist:
\begin{itemize}
\item if \texttt{target} is \texttt{nil}, it returns the value
  of \texttt{base};
\item if \texttt{target} is some \texttt{(:: elt rest)},
  where \texttt{elt} is a variable and \texttt{rest} is a list, it
  recursively calls itself with \texttt{target} replaced by \texttt{rest}.
\end{itemize}

Here is a use case, where we redefine the length function for a list. We will
use again \texttt{Pi} types, since we want it to work for lists of elements
of any type.
{
  \small
\begin{verbatim}
#lang pie

(claim length                       ; length of a list
  (Pi ((E U))                       ; using dependent types
    (-> (List E) Nat)))             ; takes a list and returns a natural
(define length
  (lambda (E)                       ; abstract the type
    (lambda (es)                    ; abstract the argument
      (rec-List es                  ; make the argument to be the target
                0
                step-length E))))   ; we need the "inductive step"

;; "inductive step" for computing length of a list
(claim step-length
  (Pi ((E U))                       ; a dependent function
    (-> E (List E) Nat Nat)))       ; takes a type, a list of elements of that type,
                                    ; a Nat and returns a Nat
(define step-length
  (lambda (E)                       ; abstract the parameter type
    (lambda (e es length-es)        ; the rest of the arguments
      (add1 length-es))))

;; special version for Atom
(claim length-Atom
  (-> (List Atom) Nat))
(define length-atom
  (length Atom))
\end{verbatim}
}

Since \texttt{length} abstracts on the type first and then the list,
a test should be written like:
\[
  \texttt{(length Nat (:: 1 (:: 2 (:: 3 nil))))} \quad \texttt{; => (the Nat 3)}
\]

\index{Pie!induction!\texttt{rec-Nat}}

We spend some space here to detail the \texttt{rec-List} function, but before doing
that, we go a little back to its simpler version, \texttt{rec-Nat}, for arguments
of type \texttt{Nat}. The general syntax follows the pattern we've seen so far:
\[
  \texttt{(rec-Nat target base step)}
\]
and also as before, when the value of \texttt{target} is \texttt{zero},
we get the value of \texttt{base}. For the \qq{inductive step}, assume
the value of \texttt{target} is some \texttt{(add1 n)}. Then \texttt{step} must
be a function of two arguments, of which the first will be bound to \texttt{n}
and the second will be bound to a recursive call of the same \texttt{rec-Nat}
expression, with \texttt{target} replaced by \texttt{n}.

Example:
{
  \small
\begin{verbatim}
(rec-Nat 
  (add1 zero)                   ; target, so n = zero, but target = 1
  0                             ; base
  (lambda (n-1 almost)          ; step (two-argument function)
    (add1 (add1 almost))))

;; first, using rec-Nat definition, reduces to:
((lambda (n-1 almost)
    (add1 (add1 almost)))
  zero
  (rec-Nat zero                 ; recursive call with target = 0
    0                           ; same base case
    (lambda (n-1 almost)        ; same step function
      (add1 (add1 almost)))))

;; then using lambda rules of computation reduces to:
(add1 (add1
        (rec-Nat zero
                 0
                 (lambda (n-1 almost)
                    (add1 (add1 almost))))))

;; and finally
(add1 (add1 0))                 ; => (the Nat 2) provided 2 is claimed and defined!
\end{verbatim}
}

A very simple and interesting application of \texttt{rec-Nat} is to define
the function for a Gauss sum. When calling \texttt{(gauss n)}, it should
return the sum of all the integers up to (including) $ n $, which is
$ \dfrac{n(n-1)}{2} $. We will be using addition for the \texttt{Nat}
type, defined in \ref{fig:plus-nat}.
{
  \small
\begin{verbatim}
#lang pie

;; the inductive step
(claim step-gauss
  (-> Nat Nat Nat))
(define step-gauss
  (lambda (n-1 gauss-n-1)
    (+ (add1 n-1) gauss-n-1)))

;; now the Gauss function
(claim gauss
  (-> Nat Nat))
(define gauss
  (lambda (n)
    (rec-Nat n
      0
      step-gauss)))
\end{verbatim}
}

\vspace{0.3cm}
\index{Pie!induction!\texttt{rec-List}}
Now the explanation for \texttt{rec-List} is similar to the \texttt{rec-Nat} case,
with the appropriate \qq{translations}:
\begin{itemize}
\item \texttt{zero} is replaced by \texttt{nil};
\item \texttt{add1} is \texttt{::}.
\end{itemize}

For typing, it follows that the eliminator \texttt{(rec-List target base step)}
has type \texttt{X} when:
\begin{itemize}
\item \texttt{target} has type \texttt{(List E)} (since it will be \qq{decomposed});
\item \texttt{base} has type \texttt{X} (since it gets returned in the base case);
\item \texttt{step} has type \texttt{(-> E (List E) X X)}, which should be
  parsed as \texttt{(E, (List E) -> X) -> X}. This is because \texttt{step} should
  be a two-argument function, first of which being the \texttt{List E} of \texttt{target}
  with an element stripped off and the second argument should be the entire
  \texttt{rec-List} expression, called with the modified \texttt{target}.
\end{itemize}

Now the innards of \texttt{length} should be transparent: it uses \texttt{rec-List}
to increase the length of the list by one, while popping out elements
from it (the \texttt{target} argument).


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../racket"
%%% End:
