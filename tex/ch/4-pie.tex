% ! TEX root = ../racket.tex
\chapter{Pie}

Pie is a language implemented in Racket meant to facilitate programming
and theorem proving with dependent types. It is best described in the
book \cite{typer}, which is written in a very original way, by means of
dialogue, as a theater play, with emphasis on interaction and asking
questions. In fact, the book is only one in a series generally titled
\emph{The Little X}, where \emph{X} so far has been
\emph{Schemer, Lisper, Prover, Haskeller}.

In this chapter, we will present some basic syntax and features of Pie
first and then insist on its implementation of dependent types. Most
of the presentation will follow \cite{typer}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Basic Syntax and Features}

Since Pie is written in Racket, its syntax is similar to Racket's.
Moreover, the language is available as a Racket module, hence it can be
installed using the Racket packet manager, \texttt{raco}. After that,
any source code file will start with the pragma (module call)
\texttt{\#lang pie} and it will be interpreted accordingly.
\index{Pie!\texttt{raco} module}

Since the language is strongly typed, that is, the user must associate a
type to each variable or function they use, all the definitions must be
preceded either by a \texttt{claim} or a \texttt{the} statement.
\index{Pie!\texttt{claim}}
\index{Pie!\texttt{the}}
\index{Pie!\texttt{define}}

A \texttt{claim} statement declares the type of a function or variable
and must precede any definition, whereas a \texttt{the} expression
does a type annotation for variables. Simple examples follow:
{
  \small
\begin{verbatim}
#lang pie

(the (Pair Atom Atom)
     (cons 'spinach 'cauliflower))
;; declares that the expression (cons 'spinach 'cauliflower)
;; makes a Pair of Atoms. more on these below

(claim one Nat)                 ; one is of type Nat
(define one (add1 zero))        ; zero is primitive
(the Nat (add1 one))            ; 2 is a Nat
\end{verbatim}
}

\index{Pie!types!\texttt{Nat}}
\index{Pie!types!\texttt{Atom}}

Two basic types that can be used are \texttt{Nat}, for positive integers,
\texttt{Atom} for quoted variables (symbols). Then, we can use
\emph{constructors} and \emph{type constructors}. An expression that is
preceded by a constructor is called a \emph{value}. For example, one constructor
of the type \texttt{Nat} is \texttt{zero}, which returns \texttt{0} and another
one is \texttt{add1}, which is basically the successor function. So for
example, we can obtain a value like so:
{
  \small
\begin{verbatim}
#lang pie

(claim two Nat)
(define two
  (add1
    (add1 zero)))
\end{verbatim}
}

Also, atoms are values, so the type \texttt{Atom} does not have a constructor:
{
  \small
\begin{verbatim}
#lang pie

(claim dog Atom)
(define dog 'dog)
\end{verbatim}
}

Then, further, we can build types using \emph{type constructors}. One example
is the type constructor \texttt{Pair} which makes a pair of elements having
(possibly) different types. A constructor for such a type is \texttt{cons}:
{
  \small
\begin{verbatim}
#lang pie

(claim myDogs (Pair Atom Atom))
(define myDogs (cons 'Ricky 'Rocky))
\end{verbatim}
}

We will meet more types and (type) constructors further, so we will explain
them on the spot. Notice that we can also use lambda expressions, as
throughout Racket.

One last important feature which we mention here is that the type theory that
we use is, in a sense, \emph{closed} or \emph{total}. That is, anything must
have a type... \emph{including types!} Without going into details, we mention
that the type of types is one all-encompassing \emph{universe}, denoted
mathematically by $ \kal{U} $ and in Pie, by \texttt{U}. We will meet universes
when we build $ \Pi $-types in Pie.
\index{Pie!types!\texttt{U} (universe)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Induction and Dependent Types}
\label{sec:induction-pi}

We now are heading towards more complex features of Pie, of which
dependent types are an essential example. But before we get there,
we will introduce some functions which work on the basis of induction.
We provide explicit examples instead of focusing on theoretical aspects.
The theory between the principle of mathematical induction was
introduced on the type of natural numbers in \S\ref{sec:nat-ind}.

\index{Pie!induction!\texttt{which-Nat}}
As such, we first introduce the Pie function \texttt{which-Nat}.
The general syntax is:
\[
  \texttt{(which-Nat \ target \ base \ step)},
\]
which is a function that acts on \texttt{Nat} variables.
It works as follows:
\begin{itemize}
\item it first checks whether \texttt{target} is \texttt{zero};
\item if it is, the function returns the value of \texttt{base};
\item otherwise, \texttt{target} must be some \texttt{(add1 n)},
  for some \texttt{n}, since these are the only kinds of values of type
  \texttt{Nat}. In this case, it returns the value of \texttt{(step n)}.
\end{itemize}

This pattern will be encountered in some other functions as well,
so we will spend a little on explaining it better. The first argument
(both for \texttt{which-Nat} and some other similar functions that we
meet is, in a sense, \qq{the main argument}, since depending on its form,
the rest happens. In the case of \texttt{Nat} values, we can only encounter
either \texttt{zero} or \texttt{add1 n}. In the first case, the function
returns \texttt{base}, as if we are in the base case of an inductive proof.
In the second case, notice that if \texttt{target} has the form
\texttt{add1 n}, then we have access to the \emph{preceding} case, \texttt{n}.
So we also have \texttt{n} and \texttt{n + 1 = (add1 n)}. The function now
offers the flexibility to go not just from \texttt{n} to \texttt{n + 1},
but from \texttt{n} to \texttt{(step n)}. By abuse of language, we will still
call this \emph{the inductive step}. As such, whenever we use \texttt{which-Nat},
as well as the other similar functions that will appear, we want to make
sure we know what to do in \emph{the base case} and in the \emph{inductive step}.
In other words, we must have useful definitions both for \texttt{base}
and for \texttt{step}.

Some simple examples with \texttt{which-Nat} follow below. Notice that since
\texttt{which-Nat} is a standard library function for Pie, we don't have
to \texttt{claim} it.
{
  \small
\begin{verbatim}
#lang pie

(which-Nat zero
           'naught
          (lambda (n) 'more))           ;; => 'naught
(which-Nat 4
           'naught
           (lambda (n) 'more))          ;; => 'more
(which-Nat 5
           0
           (lambda (n) (+ 6 n)))        ;; => 10
\end{verbatim}
}
The first case is self explanatory: the \texttt{target} is exactly
\texttt{zero}, so we just get the base case, which is \texttt{'naught}.

In the second case, the \texttt{target} is not \texttt{zero}, so we
will evaluate the \texttt{step} case. For this, we first notice that
\texttt{4 = (add1 3)}, so \texttt{n = 3} and in this case, we get
the value of \texttt{((lambda (n) 'more) 3)}, which is \texttt{'more}.
Notice that in this lambda expression, the evaluation at \texttt{n = 3}
does nothing, since the lambda associates \texttt{'more} to any argument.

In the third case, however, we do have a more meaningful lambda.
Again, \texttt{target} is not \texttt{zero}, so we get the \texttt{step}
case. Since \texttt{5 = (add1 4)}, we get:
\[
  \texttt{((lambda (n) (+ 6 n)) 4) = 10}.
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example: \texttt{Pair} Types and functions}
\label{sec:pair-ex}
\index{Pie!types!\texttt{Pair}}

Let us now define a fully custom type, along with its eliminator
and a function that acts on values of this type. Following
\cite{typer}, we will call the type \texttt{Pear}. This is actually
a custom pair of two natural numbers so in a way, we are redefining
the type \texttt{(Pair Nat Nat)}. We first present the example and
comment it afterwards:
{
  \small
\begin{verbatim}
#lang pie

(claim Pear U)                      ; claim the custom type (of universal type)
(define Pear (Pair Nat Nat))        ; a Pear is a Pair of two Nats

(claim Pear-maker U)                ; type constructor, with the universal type
(define Pear-maker                  ; actual definition of the type constructor
  (-> Nat Nat Pear))                ; a functional type from 2 Nats to a Pear

(claim elim-Pear                    ; the type eliminator
    (-> Pear Pear-maker Pear))      ; takes a (Pear, Pear-maker), gives a Pear
(define elim-Pear                   ; the definition of the eliminator
  (lambda (pear maker)              ; is a lambda taking a pear and a maker
    (maker (car pear) (cdr pear)))) ; sends the maker on the first part of pear
                                    ; and on the second part of pear

(claim pearwise+                    ; addition for Pears
  (-> Pear Pear Pear))              ; takes two Pears and returns a third one
(define pearwise+                   ; (a, b) + (c, d) = (a + c, b + d)
  (lambda (x y)                     ; take the two parts (Nats)
    (elim-Pear x                    ; split the first    (Nat)
      (lambda (a1 d1)               ; into a1 and d1     (Nats)
        (elim-Pear y                ; split the second   (Nat)
          (lambda (a2 d2)           ; into a2 and d2     (Nats)
            (cons                   ; use the Pair constructor
              (+ a1 a2)             ; to make a Pair of their added components
              (+ d1 d2))))))))
\end{verbatim}
}

Since all the definitions are actually lambda expressions, it could seem
difficult to test some examples. Here is a use case, which we will comment
afterwards:
{
  \small
\begin{verbatim}
(elim-Pear (cons 3 17)
           (lambda (a d) (cons d a)))
;; is the same as
((lambda (pear maker)
    (maker (car pear) (cdr pear)))
  (cons 3 17)
  (lambda (a d) (cons d a)))
;; which finally reduces to
(cons 17 3)
\end{verbatim}
}
\index{Pie!types!constructor}
\index{Pie!types!eliminator}

The explanations are something like this. Note that in order to correctly
evaluate \texttt{elim-Pear}, its arguments must be a \texttt{Pear}
(that is, a \qq{custom} \texttt{Pair}), which we must write using a
\texttt{cons}, to make sure the output has the required type. Otherwise,
for example, just using \texttt{(3 17)} or some other seemingly clear
pair would not do. The second argument must be a \texttt{Pear-maker},
which we can see in the code that it is a function that takes two
\texttt{Nat}s and returns a \texttt{Pear}. In our case, it is a
lambda expression with two arguments which uses \texttt{cons} to make sure
it returns a \texttt{Pear}.

Then we actually evaluate the lambda expression which is equivalent to
the \texttt{elim-Pear} expression. The outermost lambda uses two arguments,
\texttt{pear} and \texttt{maker}, so when evaluating, they bind as:
\begin{itemize}
\item \texttt{pear} becomes \texttt{(cons 3 17)};
\item \texttt{maker} becomes \texttt{(lambda (a d) (cons d a))}, which
  is just a flip function for \texttt{Pair}s (or \texttt{Pear}s).
\end{itemize}
Looking at the outermost lambda again, we see that what it does to its arguments
is to apply the \texttt{maker} to the halves of the \texttt{pear}. In our case,
taking the \texttt{car} of \texttt{pear} returns \texttt{3} and its \texttt{cdr}
is \texttt{17}. So we just \texttt{cons} them in reverse order and get
\texttt{(17 3)}. In fact, the answer of the REPL is:
\[
  \texttt{(the (Pair Nat Nat) (cons 17 3))},
\]
which shows the types explicitly.

To make matters more difficult, but also more verbose and more in the DIY
style we are taking here, if one tries to use the \texttt{pearwise+} sum,
one finds surprisingly that the \texttt{+} function is not defined! Therefore,
addition is not a part of the standard library of Pie. This makes sense in a way,
since using dependent types enforces custom definitions either in a uniform
way using \texttt{Pi} or special definitions for each type. In this case,
in order to define addition for the type \texttt{Nat}, which we need for the
components of a \texttt{Pear = (Pair Nat Nat)} type, we also require another
function which behaves somewhat inductively. This is \texttt{iter-Nat},
whose general syntax is similar to what we will be seeing more of in
\S\ref{sec:induction-pi} and \S\ref{sec:inductive-ex}. That is, we have:
\[
  \texttt{(iter-Nat target base step)},
\]
which works as follows:
\begin{itemize}
\item if the value of \texttt{target} is \texttt{zero}, it returns
  the value of \texttt{base};
\item otherwise, if \texttt{target} is some \texttt{(add1 n)},
  the value of the expression is:
  \[
    \texttt{(step (iter-Nat n base step))}.
  \]
  In other words, it performs the \qq{inductive processing step}
  on the previous case.
\end{itemize}

Having this at hand, we can define addition for the \texttt{Nat} type.
\begin{figure}[!htbp]
  
  {
    \small
\begin{verbatim}
#lang pie

;; first, define the inductive step
(claim step+ (-> Nat Nat))              ; it processes one Nat and returns another
(define step+                           ; just add one,
  (lambda (+n-1)                        ; but we renamed the argument to +n-1
    (add1 +n-1)))                       ; we are using the previous case

;; now the addition
(claim + (-> Nat Nat Nat))              ; addition for the type Nat
(define +                               
  (lambda (n j)
    (iter-Nat n j step+)))
\end{verbatim}
  }
  \caption{Addition for the \texttt{Nat} type}
  \label{fig:plus-nat}
\end{figure}

\index{Pie!induction!\texttt{iter-Nat}}

Two remarks are in order at this point. First, a general Racket remark,
which in fact applies to most Lisps: variable names can use whatever
symbols the user wishes, including \texttt{+, -, /, ?} etc. In fact,
there are even common practices with them, for example, calling a predicate
(a function that returns a Boolean) with a question mark at the end. We have
met this in \S\ref{ch:proust} for symbol parsing with \texttt{symbol?}.

The second remark is about the actual definition of \texttt{+}. Notice that
it is a two-argument function which just calls \texttt{iter-Nat}. By
definition, if the first argument \texttt{n} is \texttt{zero}, we just get
\texttt{j} (the second argument), since $ 0 + j = j $. Otherwise, we use
the \qq{inductive step} \texttt{step+} to keep adding \texttt{1}. Notice,
moreover, that by the definition of \texttt{iter-Nat}, whenever we use the
\texttt{step} case, the \texttt{target} argument decreases. So it means that
\texttt{step+} will be called exactly \texttt{n} times, for \texttt{n, n-1,}
down to \texttt{1}.

We should also add the remark that no other \texttt{Nat} is defined except
for \texttt{zero} by default. So any addition we want to test must be
preceded by the \texttt{claim} and the definition of the numbers,
such as:
{
  \small
\begin{verbatim}
#lang pie

(claim three Nat)
(define three
  (add1 (add1 (add1 zero))))

;; now test addition
(+ (add1 zero) three)           ; => (the Nat 4)
\end{verbatim}
}

\vspace{0.3cm}

This was an exercise in the definition of a custom type, along with its
maker, eliminator and a function among variables of this type. We now focus
on standard types and examine how functions on types obtained using the
\texttt{Pair} type constructor are defined using dependent types.
What we will be writing is already included in the standard library, but their
breakdown and re-implementation is useful for education purposes.

The basic idea is the following: as we mentioned in the section on
dependent types (\S\ref{sec:depty}), want we want to achieve is to be able
to define functions on variables having different types \emph{in the same way}.
Here is how some functions on \texttt{Pairs} can be implemented:
{
  \small
\begin{verbatim}
#lang pie

(claim elim-Pair                ; "consumer" (eliminator) for Pairs
  (Pi ((A U) (D U) (X U))       ; will be used throughout, since it's
    (-> (Pair A D)              ; defined on product (parametrized) types
        (-> A D X) X)))
(define elim-Pair
  (lambda (A D X)
    (lambda (p f)
      (f (car p) (cdr p)))))

(claim kar                      ; replacement for car
  (-> (Pair Nat Nat) Nat))      ; for pairs of Nats
(define kar
  (lambda (p)
    (elim-Pair Nat Nat Nat p
      (lambda (a d) a))))

(claim kdr                      ; replacement for cdr
  (-> (Pair Nat Nat Nat)))      ; for pairs of Nats
(define kdr
  (lambda (p)
    (elim-Pair Nat Nat Nat p
      (lambda (a d) d))))

;; flipping two elements of a Pair
(claim flip
  (Pi ((A U) (D U))
    (-> (Pair A D) (Pair D A))))
(define flip
  (lambda (A D)                 ; abstract types first
    (lambda (p)                 ; then the actual pair
      (cons (cdr p) (car p))))) ; flip its halves
\end{verbatim}
}

We now explain the code above, since it contains some aspects that have not
been met so far. First, notice that we define the eliminator for \texttt{Pair}
types\footnotemark, but in such a way that it uses dependent types. This way,
we use the same definition regardless of the actual types that will appear in
the arguments by a supplementary abstraction on types.
\footnotetext{Formally, we should say something like \texttt{(Pair X Y)},
  where \texttt{X} and \texttt{Y} are types, since \texttt{Pair} itself is just
  a \emph{type constructor} that takes two arguments which are types to produce
  a type. But with this remark, we acknowledge the language abuse which we've
  done and continue doing it.}

Therefore, we first need to write that \texttt{elim-Pair} will be a \texttt{Pi}
type that depends on three types \texttt{A : U, D : U, X : U}. Then, what it will
actually do is to provide a function whose first argument is of type
\texttt{Pair A D} and the second argument is another function of type
\texttt{A -> D -> X} and finally, the output will have type \texttt{X}. The action
will become clear in the definition that follows the \texttt{claim}.
As such, how this works is the following:
\begin{itemize}
\item it first abstracts with respect to types. This is a key step in a dependent
  type, since as we mentioned, it must work on various types of arguments that
  it is fed and this is the place where the types of those arguments are made
  explicit;
\item then, the action is another abstraction, this time on two arguments, one
  being a function \texttt{f} and a pair \texttt{p}. How it works is that it splits
  the \texttt{p} in two, using \texttt{car} and \texttt{cdr} and it applies the
  function to both of these halves. Its use will become even more transparent
  in the examples that follow.
\end{itemize}

Then we implement \texttt{kar}, which mimics the behaviour of \texttt{car}
for \texttt{(Pair Nat Nat)} arguments, i.e.\ it returns the first part.
After \texttt{claim}ing its type, which is precisely \texttt{(Pair Nat Nat) -> Nat},
we \texttt{define} it as follows:
\begin{itemize}
\item we use \texttt{elim-Pair}, since it is the only \qq{consumer} of \texttt{Pair}
  types;
\item the first arguments of \texttt{elim-Pair} are the actual types with respect
  to which we do the first abstraction (i.e.\ the types that enter in \texttt{Pi}).
  In this case, all three of them are \texttt{Nat};
\item lastly, the non-type argument \texttt{p}, which is exactly the pair of
  naturals. How this works is to provide a function which, given two arguments, it
  returns the first one.
\end{itemize}

Let's do a bit of \qq{pattern-matching} in this definition, namely let's match
the concrete arguments in \texttt{kar}'s definition with the generic arguments
in the definition of \texttt{elim-Pair}. First of all, as we mentioned,
\texttt{A = D = X = Nat}. Then, the second argument of \texttt{elim-Pair}
must be of type \texttt{(Pair Nat Nat) -> (Nat -> Nat -> Nat) -> Nat}.
That is, it must accept a pair of \texttt{Nat}s and a function of two
\texttt{Nat} arguments that produces a third \texttt{Nat} and finally it
must return a \texttt{Nat}. But this becomes irrelevant in this case, since
in \texttt{kar} we are abstracting by some generic \texttt{p} and make it
act like a \texttt{lambda} that returns the first half of its arguments.
That is, what \texttt{kar} is doing (after mentioning the types) is the assignment:
\[
  \texttt{p} \mapsto \left( (a, d) \mapsto a \right).
\]
It is as if \texttt{p} gets renamed to \texttt{first}.

Similarly, \texttt{kdr} is a sort of \texttt{second}.

A very similar example was the custom \texttt{elim-Pear} function we defined
and used in \S\ref{sec:pair-ex}.

Now to test the \texttt{flip} function, we need to call it accordingly.
For example, we can first make it a particular flip function for certain
types:
\[
  \texttt{(flip Nat Atom)}
\]
is just the function that requires a \texttt{(Pair Nat Atom)} argument
which it binds to \texttt{p} and is then:
\[
  \texttt{(lambda (p) (cons (cdr p) (car p)))}.
\]
A particular example is:
\[
  \texttt{((flip Nat Atom) (cons 17 'apple))},
\]
which replies with:
\[
  \texttt{(the (Pair Atom Nat) (cons 'apple 17))}.
\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Example: \texttt{List} Types and Functions}
\label{sec:inductive-ex}
\index{Pie!types!\texttt{List}}


A sort of generalization of \texttt{Pair} types are \emph{lists}.
We now show how some functions on \texttt{List} types\footnotemark can
be implemented using dependent types.
\footnotetext{Again, as in the case of \texttt{Pair}, \texttt{List} is a
  \emph{type constructor}, so formally it is not correct to say
  \qq{\texttt{List} type}. It should be something like \texttt{List X} type,
  where \texttt{X} is a type. But as in the case of \texttt{Pair}s, we
  acknowledge and keep using this expression.}

First, the prerequisites. \texttt{(List X)} is a type, where \texttt{X}
is a type and this type has two \emph{constructors}:
\begin{itemize}
\item \texttt{nil}, which makes an empty list (similar to \texttt{zero}
  for \texttt{Nat});
\item \texttt{::}, which is the equivalent of \texttt{cons} for pairs.
\end{itemize}

Also as in the case of \texttt{Nat}, we have a special \qq{inductive}
function \texttt{rec-list}. Its general syntax is:
\[
  \texttt{(rec-List target base step)}
\]
and this produces an element of type \texttt{X} when:
\begin{itemize}
\item \texttt{target} is of type \texttt{(List E)};
\item \texttt{base} is of type \texttt{X};
\item \texttt{step} is of type \texttt{(-> E (List E) X X)}.
\end{itemize}

How this works is similar to \texttt{which-Nat} with a twist:
\begin{itemize}
\item if \texttt{target} is \texttt{nil}, it returns the value
  of \texttt{base};
\item if \texttt{target} is some \texttt{(:: elt rest)},
  where \texttt{elt} is a variable and \texttt{rest} is a list, it
  recursively calls itself with \texttt{target} replaced by \texttt{rest}.
\end{itemize}

Here is a use case, where we redefine the length function for a list. We will
use again \texttt{Pi} types, since we want it to work for lists of elements
of any type.
{
  \small
\begin{verbatim}
#lang pie

(claim length                       ; length of a list
  (Pi ((E U))                       ; using dependent types
    (-> (List E) Nat)))             ; takes a list and returns a natural
(define length
  (lambda (E)                       ; abstract the type
    (lambda (es)                    ; abstract the argument
      (rec-List es                  ; make the argument to be the target
                0
                (step-length E))))) ; we need the "inductive step"

;; "inductive step" for computing length of a list
(claim step-length
  (Pi ((E U))                       ; a dependent function
    (-> E (List E) Nat Nat)))       ; takes a type, a list of elements of that type,
                                    ; a Nat and returns a Nat
(define step-length
  (lambda (E)                       ; abstract the parameter type
    (lambda (e es length-es)        ; the rest of the arguments
      (add1 length-es))))

;; special version for Atom
(claim length-Atom
  (-> (List Atom) Nat))
(define length-Atom
  (length Atom))
\end{verbatim}
}

Since \texttt{length} abstracts on the type first and then the list,
a test should be written like:
\[
  \texttt{(length Nat (:: 1 (:: 2 (:: 3 nil))))} \quad \texttt{; => (the Nat 3)}
\]

\index{Pie!induction!\texttt{rec-Nat}}

We spend some space here to detail the \texttt{rec-List} function, but before doing
that, we go a little back to its simpler version, \texttt{rec-Nat}, for arguments
of type \texttt{Nat}. The general syntax follows the pattern we've seen so far:
\[
  \texttt{(rec-Nat target base step)}
\]
and also as before, when the value of \texttt{target} is \texttt{zero},
we get the value of \texttt{base}. For the \qq{inductive step}, assume
the value of \texttt{target} is some \texttt{(add1 n)}. Then \texttt{step} must
be a function of two arguments, of which the first will be bound to \texttt{n}
and the second will be bound to a recursive call of the same \texttt{rec-Nat}
expression, with \texttt{target} replaced by \texttt{n}.

Example:
{
  \small
\begin{verbatim}
(rec-Nat 
  (add1 zero)                   ; target, so n = zero, but target = 1
  0                             ; base
  (lambda (n-1 almost)          ; step (two-argument function)
    (add1 (add1 almost))))

;; first, using rec-Nat definition, reduces to:
((lambda (n-1 almost)
    (add1 (add1 almost)))
  zero
  (rec-Nat zero                 ; recursive call with target = 0
    0                           ; same base case
    (lambda (n-1 almost)        ; same step function
      (add1 (add1 almost)))))

;; then using lambda rules of computation reduces to:
(add1 (add1
        (rec-Nat zero
                 0
                 (lambda (n-1 almost)
                    (add1 (add1 almost))))))

;; and finally
(add1 (add1 0))                 ; => (the Nat 2) provided 2 is claimed and defined!
\end{verbatim}
}

A very simple and interesting application of \texttt{rec-Nat} is to define
the function for a Gauss sum. When calling \texttt{(gauss n)}, it should
return the sum of all the integers up to (including) $ n $, which is
$ \dfrac{n(n-1)}{2} $. We will be using addition for the \texttt{Nat}
type, defined in \ref{fig:plus-nat}.
{
  \small
\begin{verbatim}
#lang pie

;; the inductive step
(claim step-gauss
  (-> Nat Nat Nat))
(define step-gauss
  (lambda (n-1 gauss-n-1)
    (+ (add1 n-1) gauss-n-1)))

;; now the Gauss function
(claim gauss
  (-> Nat Nat))
(define gauss
  (lambda (n)
    (rec-Nat n
      0
      step-gauss)))
\end{verbatim}
}

\vspace{0.3cm}
\index{Pie!induction!\texttt{rec-List}}
Now the explanation for \texttt{rec-List} is similar to the \texttt{rec-Nat} case,
with the appropriate \qq{translations}:
\begin{itemize}
\item \texttt{zero} is replaced by \texttt{nil};
\item \texttt{add1} is \texttt{::}.
\end{itemize}

For typing, it follows that the eliminator \texttt{(rec-List target base step)}
has type \texttt{X} when:
\begin{itemize}
\item \texttt{target} has type \texttt{(List E)} (since it will be \qq{decomposed});
\item \texttt{base} has type \texttt{X} (since it gets returned in the base case);
\item \texttt{step} has type \texttt{(-> E (List E) X X)}, which should be
  parsed as \texttt{(E, (List E) -> X) -> X}. This is because \texttt{step} should
  be a two-argument function, first of which being the \texttt{List E} of \texttt{target}
  with an element stripped off and the second argument should be the entire
  \texttt{rec-List} expression, called with the modified \texttt{target}.
\end{itemize}

Now the innards of \texttt{length} should be transparent: it uses \texttt{rec-List}
to increase the length of the list by one, while popping out elements
from it (the \texttt{target} argument).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{More on Product Types}

This section and its subsequents will be heavily based on the first chapter of
\cite{hott} and the idea is to insist on some theoretical aspects of certain
composite types, after which we will see if and how they can be implemented
in Pie. There are some intentional design decisions that impose certain
limits on Pie and we will see how they can be eluded.

First, assume we have two types $ A, B : \kal{U} $ and we want to introduce
their product type $ A \times B : \kal{U} $, which is called their
\emph{(Cartesian) product type.} In the particular case when make the
void choice both for $ A $ and $ B $, we get the \emph{unit type},
also called the \emph{nullary product type}, denoted by $ \pmb{1} : \kal{U} $.

The canonical elements of type $ A \times B $ will be pairs of the form
$ (a, b) $, where $ a : A $ and $ b : B $, whereas the unique element of
type $ \pmb{1} $ is denoted by some generic $ \ast : \pmb{1} $.

Note that if in set theory, both functions and (ordered) pairs are constructed,
in type theory they are taken as primitive concepts, both of them.

Hence, we have above, in MLTT parlance, the \emph{introduction rules}:
$ A \times B \text{ type} $, for $ A \text{ type } $ and $ B \text{ type} $.
Or, using universes: $ A \times B : \kal{U} $, for $ A, B : \kal{U} $ and
similarly for the unit type $ \ast : \pmb{1} $ (for the void choice).

For the constructor of this type, we make use of the \emph{uniqueness principle}
(which can be proved using equality types and for which we refer the reader
to \cite[p.\ 29]{hott}), which states that all elements of type $ A \times B $
are ordered pairs. So if we know how to construct ordered pairs, we can inhabit
product types. But there is nothing to prove, since we assumed that pairs are
primitive concepts. That is, starting with $ a : A $ and $ b : B $, we can
directly construct $ (a, b) : A \times B $.

Now we need the \emph{type eliminators}, which show us how to use ordered pairs.
For this purpose, we want to construct functions out of product types, i.e.\
functions which take pairs as arguments. We will do this by relying on previously
introduced types, namely function types (with their constructor, $ \lambda $).
So, we start with a function $ g : A \to B \to C $, or, in other words, with
the function type $ A \to B \to C $, inhabited by some $ g $. This type can be
parsed as $ (A \to B) \to C $, so $ g $ is some $ \lambda a . \lambda b . \Phi $\footnotemark,
where $ \Phi $ is a functional expression that may or may not contain $ a $ and $ b $.\footnotemark
\footnotetext{This explicit, iterated lambda expression is sometimes called the
  \emph{uncurried} version for a two-argument function. There is also the
  \emph{curried} version, written as $ \lambda ab.\Phi $, which is explicit
  enough.}
\footnotetext{We should have been more explicit by using \emph{typed} lambda
  expressions, i.e.\ $ \lambda (a : A) . \lambda (b : B) . \Phi $, but we
  omitted the types, hoping they are understood from the context.}

Using this $ g $, we want to construct $ f : A \times B \to C $. This
is easy and we have the \emph{elimination rule} for product types
which is the definitional equality below:
\[
  f((a, b)) :\equiv g(a)(b).
\]

There are two particular cases of interest, namely the \emph{canonical projection}
functions:
\[
  p_1 : (a, b) \mapsto a, \quad p_2 : (a, b) \mapsto b.
\]

And furthermore, they can be put in a more general framework using a function
that is called a \emph{recursor} for product types:
\begin{align*}
  &\dr{rec}_{A \times B} : \prod_{C : \kal{U}} (A \to B \to C) \to A \times B \to C \\
  &\dr{rec}_{A \times B}(C, g, (a, b)) :\equiv g(a)(b).
\end{align*}

This function is parametrized by some type $ C : \kal{U} $ and has two arguments:
one is a two-valued \emph{dependent function} $ A \to B \to C $ and the other
is a pair of type $ A \times B $. Using this, we can recover the projection
functions by the following definitional equalities:
\begin{align*}
  p_1 &:\equiv \dr{rec}_{A \times B}(A, \lambda ab . a) \\
  p_2 &:\equiv \dr{rec}_{A \times B}(B, \lambda ab . b).
\end{align*}

For the unit type, this is trivial:
\[
  \dr{rec}_{\pmb{1}} : \prod_{C : \kal{U}} C \to \pmb{1} \to C, \quad %
  \dr{rec}_{\pmb{1}}(C, c, \ast) :\equiv c.
\]

\vspace{0.3cm}

Now onto the Pie implementation. We have already met the \texttt{Pair} type
constructor, which can be seen as the Cartesian product. That is, if
\texttt{A} and \texttt{B} are types, \texttt{(Pair A B)} is a product
type. We already know which are its eliminators, namely \texttt{car} and
\texttt{cdr}, which are, respectively, the first and second projection.
Moreover, its constructor is \texttt{cons}.

Therefore, we continue by adding the unit type and the recursor.
The unit type is built-in Pie and it is called \texttt{Trivial}. Its
only element (or constructor) is called \texttt{sole}. Hence, the
expression \texttt{(the Trivial sole)} does the typing $ \ast : \pmb{1} $.

As for the recursor, there are two particular shortcomings of Pie, which are
actually intentional design decisions\footnotemark, but they can be overcame.
\footnotetext{Thank you, David Thrane Christiansen for explaining them to me!}

First, there are no ``generic types'' in Pie, so there is no equivalent of
$ A : \kal{U} $, so we have to use particular types that are built-in the
language, such as \texttt{Nat} or \texttt{Atom}.

Second, the \texttt{Pi} type constructor for dependent types must bind
all types that appear in its \texttt{claim}. That is, we will not be able
to make explicit the fact that the recursor $ \dr{rec}_{A \times B} $ uses
some \emph{fixed} types $ A $ and $ B $ and the only type parameter is
$ C $.

Those being said, an implementation can be as follows:
{
  \small
\begin{verbatim}
#lang pie

(claim recAxB
       (Pi ((A U) (B U) (C U))              ; as if all are type params
           (-> (-> A B C) (Pair A B) C)))
(define recAxB
  (lambda (A B C)                           ; abstract (all) the types first
    (lambda (g p)                           ; g is (lambda ab.F) and p is a Pair
      ((g (car p)) (cdr p)))))
\end{verbatim}
}

And now for example, we can test as follows:
{
  \small
\begin{verbatim}
((recAxB Nat Nat Nat) 
    (lambda (x y) (add1 y)) (cons 2 3))     ; => (the Nat 4)
;;  |------ g ------------| |--- p ----|
\end{verbatim}
}

We can also define the first projection for the \texttt{Nat} type
using the recursor by:
{
  \small
\begin{verbatim}
(claim p1 (-> (Pair Nat Nat) Nat))
(define p1
  ((recAxB Nat Nat Nat)
     (lambda (x y) x)))

;; test
(p1 (cons 2 3))                             ; => (the Nat 2)
\end{verbatim}
}

For the particular case of the unit type, we have:
{
  \small
\begin{verbatim}
(claim recU
  (Pi ((C U)) (-> C Trivial C)))
(define recU
  (lambda (C)
    (lambda (c d) c)))                      ; d can only be sole

;; test
((recU Trivial) sole sole)                  ; => (the Trivial sole)
((recU Nat) zero sole)                      ; => (the Nat 0)
\end{verbatim}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \section{Dependent Pair Types}

% Given a pair type, we can allow one of the arguments to be a parameter.
% We get this by constructing \emph{dependent pair types} or $ \Sigma $ types.
% That is, we start with a fixed type $ A : \kal{U} $ and a \emph{type family}
% $ B : A \to \kal{U} $, which is inhabited by some $ B(x) $ for $ x : A $.
% In other words, for each $ x : A $, we construct a (possibly different)
% dependent type $ B(x) $. The $ \Sigma $ types are denoted by
% $ \Sum_{x : A} B(x) $.

% To construct elements of a dependent pair types, we basically explain the
% concept: they are inhabited by ordered pairs, of which the second element has
% a variable type. That is, we have $ (a, b) : \Sum_{x : A} B(x) $ starting
% from $ a : A $ and $ b : B(a) $. Of course, in the particular case
% when $ B $ is constant (i.e.\ we always choose the same $ x : A $ as
% parameter or no parameter at all or we simply ignore the parameter and
% always choose the same $ B $), we get the regular Cartesian product
% type, which is written as:
% \[
%   \Sum_{x : A} B \equiv A \times B.
% \]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Coproduct (Sum) Types}

Starting with two types $ A, B : \kal{U} $, we can form their \emph{coproduct}
or \emph{sum} type, denoted by $ A + B : \kal{U} $. This corresponds to disjoint
unions in set theory, i.e.\ unions in which one can always identify precisely
from where are the elements taken, either from the first term or from the second.

The nullary version, where we don't choose neither $ A $ nor $ B $ is the
\emph{null type}, which doesn't distinguish its elements and which we denote
by $ \pmb{0} : \kal{U} $.

Having said this, it is clear that to construct elements of type $ A + B $,
we need the so-called \emph{left (right) injections}, which we denote by
$ \dr{inl}(a) : A + B $ for some $ a : A $ and $ \dr{inr}(b) : A + B $
for some $ b : B $.

Now, eliminators for this type, i.e. functions $ f : A + B \to C $ are
constructed by components. That is, we need functions $ g_l : A \to C $
and $ g_r : B \to C $ and then define:
\[
  f(\dr{inl}(a)) :\equiv g_l(a), \quad
  f(\dr{inr}(b)) :\equiv g_r(b)
\]
and invoke a \emph{uniqueness principle} for coproduct types, which states
that all elements of such type are left (or right) injections. This means
that the definition above is by \emph{exhaustive case analysis.}

As in the case of product types, we have a recursor for sum types,
namely:
\begin{align*}
  &\dr{rec}_{A + B} : \prod_{C : \kal{U}} (A \to C) \to (B \to C) \to A + B \to C \\
  &\dr{rec}_{A + B} (C, g_l, g_r, \dr{inl}(a)) :\equiv g_l(a) \\
  &\dr{rec}_{A + B} (C, g_l, g_r, \dr{inr}(b)) :\equiv g_r(b).
\end{align*}

Since there are no elements of type $ \pmb{0} $, we trivially construct
a function $ f : \pmb{0} \to C $ by providing no equations. So basically
the recursor is:
\[
  \dr{rec}_{\pmb{0}} : \prod_{C : \kal{U}} \pmb{0} \to C,
\]
which constructs a canonical element of type $ C $ starting from nothing.
This is the type theoretical expression of the logical principle
\emph{ex falso quodlibet}, which states that a false statement can imply
anything. That is, starting with a false assumption, we can derive anything.

\vspace{0.3cm}

Now onto the Pie implementation. Conveniently enough, Pie already contains
the coproduct types, whose type constructor is \texttt{Either}. That is,
if \texttt{A} and \texttt{B} are types, then \texttt{(Either A B)} is their
sum type written mathematically as $ A + B $. Its constructors are
\texttt{left} and \texttt{right}, which means that \texttt{a} is of type
\texttt{A}, then \texttt{(left a)} has type \texttt{(Either A B)}
and if \texttt{b} is of type \texttt{B}, then \texttt{(right b)} has
type \texttt{(Either A B)}.

Also, \texttt{Absurd} is the empty type.

This means we can readily adapt the recursor for product types in order to
get the version for sum types:
{
  \small
\begin{verbatim}
#lang pie

(claim recA+B-left
    (Pi ((A U) (B U) (C U))
        (-> (-> A C) (-> B C) (Either A B) C)))

(claim recA+B-right
    (Pi ((A U) (B U) (C U))
        (-> (-> A C) (-> B C) (Either A B) C)))

(define recA+B-left
  (lambda (A B C)
    (lambda (gl gr (left a)
      (gl a)))))

(define recA+B-right
  (lambda (A B C)
    (lambda (gl gr (right b)
      (gr b)))))

;; test
???
\end{verbatim}
}





%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../racket"
%%% End:
